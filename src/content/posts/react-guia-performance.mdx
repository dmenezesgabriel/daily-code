---
title: "O Guia Definitivo de Performance em React"
date: "2023-05-20"
category: "Desenvolvimento"
image:
  src: "./daily-code/assets/images/react-performance-hooks.png"
  alt: ""
---

JÃ¡ se perguntou por que Ã s vezes sua aplicaÃ§Ã£o React parece estar correndo uma maratona com chinelos? ğŸƒâ€â™‚ï¸ Bem, vocÃª nÃ£o estÃ¡ sozinho! Vamos mergulhar nos segredos da performance em React e transformar sua aplicaÃ§Ã£o em um verdadeiro corredor olÃ­mpico. ğŸ…

## O MÃ¡gico Algoritmo de ReconciliaÃ§Ã£o

Antes de mais nada, precisamos entender como o React faz sua mÃ¡gica por baixo dos panos. O processo de reconciliaÃ§Ã£o Ã© como um maestro organizando uma orquestra digital:

1. Primeiro, o React cria uma DOM virtual (VDOM) - imagine isso como um rascunho do que sua UI deveria ser
2. Em seguida, ele compara esse rascunho com a DOM atual usando um algoritmo de diferenciaÃ§Ã£o
3. Por fim, atualiza apenas o que realmente mudou, como um cirurgiÃ£o preciso ğŸ”ª

```jsx
// Exemplo de como o React vÃª suas mudanÃ§as
const previousState = <UserProfile name="John" role="developer" />;
const currentState = <UserProfile name="John" role="senior developer" />;
// React: "Hmm, sÃ³ preciso atualizar o texto do role, o resto permanece!"
```

### Componentes Funcionais Puros: A Base da Previsibilidade

Antes de mergulhar no `memo`, vamos entender o que sÃ£o componentes puros. SÃ£o componentes que, para as mesmas props, sempre retornam o mesmo resultado - como uma funÃ§Ã£o matemÃ¡tica bem comportada:

```jsx
// âœ… Componente Puro
const PriceDisplay = ({ price, currency }) => (
  <span>
    {currency}
    {price.toFixed(2)}
  </span>
);

// âŒ Componente Impuro - depende de estado externo
const CurrentTimeDisplay = () => <span>{new Date().toLocaleTimeString()}</span>;
```

## memo: Seu Melhor Amigo na OtimizaÃ§Ã£o

O `memo` Ã© como um seguranÃ§a VIP para seus componentes. Ele impede re-renderizaÃ§Ãµes desnecessÃ¡rias, mas nÃ£o saia usando em todo lugar! Use com sabedoria nos seguintes casos:

### Quando Usar memo:

1. Em componentes funcionais puros (que sempre retornam o mesmo resultado para as mesmas props)
2. Componentes que renderizam frequentemente
3. Componentes que recebem as mesmas props repetidamente
4. Componentes de tamanho mÃ©dio para grande

```jsx
const ProductList = memo(({ products, onProductClick }) => {
  return (
    <div className="grid grid-cols-3 gap-4">
      {products.map((product) => (
        <ProductCard key={product.id} {...product} onClick={onProductClick} />
      ))}
    </div>
  );
});

// Uso do componente
const ProductPage = () => {
  const [products, setProducts] = useState([]);

  // Este callback sÃ³ muda se realmente precisar
  const handleProductClick = useCallback((productId) => {
    console.log(`Product ${productId} clicked`);
  }, []);

  return (
    <ProductList products={products} onProductClick={handleProductClick} />
  );
};
```

## A Arte da ComparaÃ§Ã£o Rasa (Shallow Comparison)

Aqui estÃ¡ onde as coisas ficam interessantes! React usa comparaÃ§Ã£o rasa por padrÃ£o, e isso Ã© mais importante que muitos percebem:

### Igualdade Referencial: Os GÃªmeos ğŸ¤”

```jsx
// Primitivos: GÃªmeos idÃªnticos
const userId = 42;
const anotherUserId = 42;
console.log(userId === anotherUserId); // true, sÃ£o literalmente idÃªnticos!

// Objetos: GÃªmeos que apenas se vestem igual
const user1 = { id: 42, name: "Alice" };
const user2 = { id: 42, name: "Alice" };
console.log(user1 === user2); // false, parecem iguais mas sÃ£o pessoas diferentes!

// SoluÃ§Ã£o: Clone memorizado
const userRef = useMemo(() => ({ id: 42, name: "Alice" }), []);
```

## useMemo: O bicho preguiÃ§a

Pense no `useMemo` como aquele pessoa que acorda e fica o dia todo de pijama uma vez que a noite voltara a dormir. Muito Ãºtil quando:

1. VocÃª tem cÃ¡lculos pesados que nÃ£o precisam ser refeitos a cada renderizaÃ§Ã£o
2. Precisa manter a referÃªncia de objetos estÃ¡vel

```jsx
const Dashboard = ({ transactions }) => {
  const expensiveStats = useMemo(
    () => ({
      total: transactions.reduce((sum, t) => sum + t.amount, 0),
      average:
        transactions.reduce((sum, t) => sum + t.amount, 0) /
        transactions.length,
      maxTransaction: Math.max(...transactions.map((t) => t.amount)),
      recentTransactions: transactions.slice(-5).map((t) => t.amount),
    }),
    [transactions],
  );

  return (
    <div>
      <StatsDisplay stats={expensiveStats} />
      <TransactionList transactions={transactions} />
    </div>
  );
};
```

## useCallback: O Valet das FunÃ§Ãµes

`useCallback` Ã© como um serviÃ§o de valet parking para suas funÃ§Ãµes. Ele guarda a referÃªncia da sua funÃ§Ã£o e sÃ³ cria uma nova quando realmente necessÃ¡rio. Ou seja, quando chegar um carro mais caro no pedaÃ§o o seu fusquinha 87 pode acabar indo para outra vaga.

### Casos de Uso Perfeitos:

1. FunÃ§Ãµes passadas como props para componentes memorizados
2. FunÃ§Ãµes usadas em efeitos
3. FunÃ§Ãµes que precisam manter sua identidade entre renderizaÃ§Ãµes

```jsx
const SearchComponent = () => {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState([]);

  const handleSearch = useCallback(async (searchQuery) => {
    try {
      const response = await api.search(searchQuery);
      setResults(response.data);
    } catch (error) {
      console.error("Search failed:", error);
    }
  }, []); // FunÃ§Ã£o estÃ¡vel que nÃ£o precisa ser recriada

  const debouncedSearch = useMemo(
    () => debounce(handleSearch, 300),
    [handleSearch],
  );

  return (
    <div>
      <SearchInput
        value={query}
        onChange={(e) => {
          setQuery(e.target.value);
          debouncedSearch(e.target.value);
        }}
      />
      <SearchResults results={results} />
    </div>
  );
};
```

## Exemplos PrÃ¡ticos de Componentes Puros

Vamos ver alguns exemplos prÃ¡ticos de componentes puros vs. impuros e como isso afeta a performance:

```jsx
// âœ… Componente Puro - Perfeito para memo!
const UserAvatar = memo(({ user, size = 'md' }) => {
  const dimensions = {
    sm: 32,
    md: 48,
    lg: 64
  }[size];

  return (
    <img
      src={user.avatarUrl}
      alt={`${user.name}'s avatar`}
      width={dimensions}
      height={dimensions}
      className="rounded-full"
    />
  );
});

// âŒ Componente Impuro - Evite isso!
const UserStatus = ({ userId }) => {
  // Estado externo torna o componente impuro
  const [isOnline, setIsOnline] = useState(false);

  useEffect(() => {
    // DependÃªncia externa de websocket
    const ws = new WebSocket('ws://api.example.com');
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.userId === userId) {
        setIsOnline(data.online);
      }
    };
    return () => ws.close();
  }, [userId]);

  return (
    <div className={`status-dot ${isOnline ? 'bg-green-500' : 'bg-gray-400'}`} />
  );
});

// âœ… VersÃ£o Pura Refatorada - Agora sim!
const UserStatus = memo(({ isOnline }) => (
  <div className={`status-dot ${isOnline ? 'bg-green-500' : 'bg-gray-400'}`} />
));

// Componente pai gerencia o estado
const UserStatusContainer = ({ userId }) => {
  const [isOnline, setIsOnline] = useState(false);

  useEffect(() => {
    // LÃ³gica do WebSocket movida para o container
    const ws = new WebSocket('ws://api.example.com');
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.userId === userId) {
        setIsOnline(data.online);
      }
    };
    return () => ws.close();
  }, [userId]);

  return <UserStatus isOnline={isOnline} />;
};
```

Este padrÃ£o de separar a lÃ³gica de estado do componente de apresentaÃ§Ã£o Ã© conhecido como "Container/Presentational Pattern" e Ã© uma excelente maneira de criar componentes puros e otimizÃ¡veis! ğŸ¯

## ConclusÃ£o

Performance em React nÃ£o precisa ser um bicho de sete cabeÃ§as! Com essas ferramentas no seu cinto de utilidades, vocÃª estÃ¡ pronto para criar aplicaÃ§Ãµes mais rÃ¡pidas que um Fusca turbinado! ğŸš€

Lembre-se: otimizaÃ§Ã£o prematura Ã© a raiz de todo mal. Use estas tÃ©cnicas com sabedoria e apenas quando necessÃ¡rio. Afinal, o melhor cÃ³digo Ã© aquele que funciona bem e Ã© fÃ¡cil de manter!
